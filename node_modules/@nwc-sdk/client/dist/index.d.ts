import { OpenAPIV2 } from 'openapi-types';
import { Collection } from 'postman-collection';

export declare type ApiRequestOptions = {
	readonly method: "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH";
	readonly url: string;
	readonly path?: Record<string, any>;
	readonly cookies?: Record<string, any>;
	readonly headers?: Record<string, any>;
	readonly query?: Record<string, any>;
	readonly formData?: Record<string, any>;
	readonly body?: any;
	readonly mediaType?: string;
	readonly responseHeader?: string;
	readonly errors?: Record<number, string>;
};
export declare class CancelError extends Error {
	constructor(message: string);
	get isCancelled(): boolean;
}
export interface OnCancel {
	readonly isResolved: boolean;
	readonly isRejected: boolean;
	readonly isCancelled: boolean;
	(cancelHandler: () => void): void;
}
export declare class CancelablePromise<T> implements Promise<T> {
	readonly [Symbol.toStringTag]: string;
	private _isResolved;
	private _isRejected;
	private _isCancelled;
	private readonly _cancelHandlers;
	private readonly _promise;
	private _resolve?;
	private _reject?;
	constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: OnCancel) => void);
	then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
	catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult>;
	finally(onFinally?: (() => void) | null): Promise<T>;
	cancel(): void;
	get isCancelled(): boolean;
}
export declare type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
export declare type Headers = Record<string, string>;
export declare type OpenAPIConfig = {
	BASE: string;
	VERSION: string;
	WITH_CREDENTIALS: boolean;
	CREDENTIALS: "include" | "omit" | "same-origin";
	TOKEN?: string | Resolver<string>;
	USERNAME?: string | Resolver<string>;
	PASSWORD?: string | Resolver<string>;
	HEADERS?: Headers | Resolver<Headers>;
	ENCODE_PATH?: (path: string) => string;
};
export declare const OpenAPI: OpenAPIConfig;
export declare abstract class BaseHttpRequest {
	readonly config: OpenAPIConfig;
	constructor(config: OpenAPIConfig);
	abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;
}
export declare type connectionSchema = {
	title: string;
	description?: string;
	type: string;
	properties: any;
	required?: Array<string>;
	ownership?: boolean;
};
export declare type contract = {
	id: string;
	name: string;
	description?: string;
	appId: string;
	createdByUserId?: string;
	timeStamp?: string;
	createdDate?: string;
	icon: string;
	operations?: Array<{
		operationId?: string;
		name?: string;
		type?: string;
		apps?: Array<string>;
	}>;
	allowedHosts?: Array<string>;
	latestVersion?: string;
	latestScheme?: string;
};
export declare type datasource = {
	id: string;
	name: string;
	description: string;
	contractId: string;
	operationId: string;
	connectionId: string;
	createdByUserId?: string;
	createdDate?: string;
	modifiedByUserId?: string;
	modifiedDate?: string;
	isInvalid?: boolean;
	isEditable?: boolean;
	definition: string;
};
export declare type exportWorkflowResponse = {
	key: string;
	expiryDate?: string;
};
export declare type user = {
	id: string;
	first_name?: string;
	last_name?: string;
	vibranium_enabled?: boolean;
	is_guest?: boolean;
	organization_id?: string;
	legacy_id?: string;
	roles?: Array<string>;
	permissions?: Array<string>;
	tenantId?: string;
	tenantName?: string;
	name?: string;
	firstName?: string;
	lastName?: string;
	email?: string;
	nintexTenantId?: string;
	displayName?: string;
};
export declare type importWorkflowResponse = {
	workflowId: {
		workflowId?: string;
		workflowDesignVersion?: string;
	};
	isActive: boolean;
	author?: user;
	eventType?: string;
	isPublished: boolean;
	created?: string;
	isDeleted: boolean;
	lastModified?: string;
	workflowDescription?: string;
	workflowName: string;
	publishAuthor?: user;
	publishedId?: string;
	lastPublished?: string;
	workflowType: string;
	saveAuthor?: user;
	lastEdited?: string;
	status: string;
};
export declare type saveWorkflowResponse = {
	workflowId: string;
	workflowDesignVersion: string;
};
export declare type tag = {
	name: string;
	colorIndex: number;
	count: number;
	kind?: string;
};
export declare type tagResponse = {
	success: boolean;
	resource: Array<tag>;
};
export declare type tenantConfiguration = {
	apiManagerUrl: string;
	zincUrl?: string;
	pdfFormConverterUrl?: string;
	webTaggerUrl?: string;
	launchDarklyKey?: string;
	whiteListedConnections?: Array<string>;
	gaTrackingCode?: string;
	designerUrl?: string;
	embedFormsUrl?: string;
	connectionsXcomponentUrl?: string;
	userManagementXcomponent?: {
		redirectUri?: string;
		documentationUrl?: string;
		url?: string;
	};
	devTokenManagementXcomponent?: {
		url?: string;
		redirectUri?: string;
	};
	domainManagementXComponent?: {
		url?: string;
		redirectUri?: string;
	};
	appInsights?: {
		instrumentationKey?: string;
		connectionString?: string;
	};
	feedbackFormEndpoint?: string;
	createTicketFormEndpoint?: string;
	appInsightsInstrumentationKey?: string;
	cloudElementService?: boolean;
	serviceRegion: string;
	boxAppUrl?: string;
	allowedHawkeyeDomains?: string;
	readmeIOUrl?: string;
	devPortalUrls?: {
		queryJson?: string;
		regex?: string;
	};
	oidc?: {
		domain?: string;
		clientId?: string;
	};
	user?: user;
};
export declare type tenantInfo = {
	id: string;
	name: string;
	organization_id: string;
	tenancy_url: string;
	created?: string;
	license?: {
		type?: string;
		start?: string;
		end?: string;
		contract_id?: string;
		entitlement?: string;
	};
	region: string;
	region_name?: string;
	aliases?: Array<string>;
	owner?: {
		email?: string;
		first_name?: string;
		last_name?: string;
	};
	source?: string;
	contract_id?: string;
};
export declare type tokenResponse = {
	access_token: string;
	scope?: string;
	expires_in?: number;
	expires_at?: string;
	token_type?: string;
};
export declare type permissionItem = {
	id: string;
	name: string;
	type: string;
	email?: string;
	subtext?: string;
	scope?: {
		own?: boolean;
		use?: boolean;
		owner?: boolean;
		user?: boolean;
	};
};
export declare type workflowStartEvent = {
	eventGroup?: string;
	eventType: string;
	eventTypeOption?: string;
	eventTypeDisplayName?: string;
	configuration?: Array<string>;
	nativeEventConfiguration?: string;
	properties?: Array<string>;
	xtensionEventConfiguration?: string;
	transformation?: string;
	webformDefinition?: string;
	webformVersion?: string;
	metadataConfiguration?: string;
	formMetadata?: {
		publishToUrlOnly?: boolean;
		publishToAllOrg?: boolean;
		participantVisible?: boolean;
	};
};
export declare type workflow = {
	workflowId: string;
	isActive: boolean;
	author?: user;
	eventType?: string;
	isPublished: boolean;
	created?: string;
	creator?: user;
	datasources?: string;
	engineName: string;
	eventConfiguration?: string;
	hasPermissions?: boolean;
	isDeleted: boolean;
	lastEdited?: string;
	lastModified?: string;
	lastPublished?: string;
	latestId: string;
	publishedId?: string;
	status: string;
	version: number;
	workflowDescription?: string;
	workflowName: string;
	workflowVersionComments?: string;
	publishAuthor?: user;
	workflowType: string;
	workflowDefinition: string;
	startEvents?: Array<workflowStartEvent>;
	permissions?: Array<permissionItem>;
	workflowDesignVersion?: string;
	isLatest?: boolean;
	publishRequestedBy?: user;
	tags?: Array<tag>;
};
export declare type workflowEndpoints = {
	url?: string;
	endpoints?: Array<{
		type?: string;
		title?: string;
		headers?: Array<string>;
		url?: string;
		payload?: string;
		urlToken?: string;
	}>;
};
export declare type connection = {
	id: string;
	displayName: string;
	isInvalid?: boolean;
	createdDate?: string;
	contractName: string;
	contractId: string;
	createdByUserId?: string;
	ownership?: boolean;
};
export declare type actionDefinition = {
	type: string;
	name: string;
	enabled: boolean;
};
export declare type connector = {
	id: string;
	name: string;
	enabled: boolean;
	events: Array<actionDefinition>;
	actions: Array<actionDefinition>;
};
export declare type datasourcePayload = {
	name: string;
	description: string;
	contractId: string;
	operationId: string;
	connectionId: string;
	definition: string;
};
export declare type updateWorkflowPayload = {
	author?: user;
	businessOwners?: Array<permissionItem>;
	datasources: string;
	engineName: string;
	permissions: Array<permissionItem>;
	startEvents?: Array<workflowStartEvent>;
	tags?: Array<tag>;
	version?: number;
	workflowDefinition?: string;
	workflowDescription?: string;
	workflowDesignParentVersion?: string;
	workflowName: string;
	workflowType?: string;
	workflowVersionComments?: string;
	scheduledstart?: workflowEndpoints;
};
export declare type eventConfiguration = Array<{
	name: string;
	value?: Array<string>;
}>;
export declare type eventType = {
	id: string;
	name: string;
};
export declare type urls = {
	designerUrl?: string;
	formUrl?: string;
};
export declare type workflowDetails = {
	id: string;
	author?: user;
	description?: string;
	created?: string;
	eventType?: eventType;
	eventConfiguration?: eventConfiguration;
	urls?: urls;
};
export declare type draftWorkflowDetails = (workflowDetails & {
	lastModified?: string;
});
export declare type publishedWorkflowDetails = (workflowDetails & {
	publishedType: publishedWorkflowDetails.publishedType;
	isActive: boolean;
	lastPublished?: string;
});
export declare namespace publishedWorkflowDetails {
	enum publishedType {
		PRODUCTION = "Production",
		DEVELOPMENT = "Development"
	}
}
export declare type workflowDesign = {
	id: string;
	draft?: draftWorkflowDetails;
	published?: publishedWorkflowDetails;
	lastModified?: string;
	name: string;
	businessOwners: Array<permissionItem>;
	tags?: Array<any>;
	engine: string;
	publishRequestedBy?: string;
};
export declare type getTokenOptions = {
	client_id: string;
	client_secret: string;
	grant_type: "client_credentials";
};
export declare type getTenantConnectorsResponseType = {
	connectors: Array<connector>;
};
export declare type getTenantConnectionsResponseType = {
	connections: Array<connection>;
};
export declare type getDatasourceTokenResponseType = {
	token?: string;
};
export declare type getTenantDatasourcesResponseType = {
	datasources: Array<datasource>;
};
export declare type createDatasourcePayload = datasourcePayload;
export declare type createConnectionProperties = Record<string, string>;
export declare type getWorkflowDesignsResponseType = {
	workflows: Array<workflowDesign>;
};
export declare type exportWorkflowOptions = {
	isNonExpiring: boolean;
};
export declare type importWorkflowOptions = {
	name: string;
	key: string;
	overwriteExisting?: boolean;
	author: {
		id?: string;
		name?: string;
		tenantId?: string;
	};
};
export declare type saveWorkflowPayload = updateWorkflowPayload;
export declare type publishWorkflowPayload = updateWorkflowPayload;
export declare type scheduleWorkflowPayload = updateWorkflowPayload;
export declare type getTenantUsersResponseType = {
	users: Array<user>;
};
export declare type getWorkflowOwnersResponseType = {
	permissions: Array<permissionItem>;
};
export declare type updateWorkflowOwnersPermissions = {
	permissions?: Array<permissionItem>;
};
export declare type getWorkflowBusinessOwnersResponseType = {
	businessOwners: Array<permissionItem>;
};
export declare type updateWorkflowBusinessOwnersBusinessOwners = {
	businessOwners?: Array<permissionItem>;
};
export declare type getConnectionPermissionsResponseType = {
	permissions: Array<permissionItem>;
};
export declare type updateConnectionPermissionsPermissions = {
	permissions?: Array<permissionItem>;
};
export declare type getDatasourcePermissionsResponseType = {
	permissions?: Array<permissionItem>;
};
export declare type updateDatasourcePermissionsPermissions = {
	permissions?: Array<permissionItem>;
};
export declare class DefaultService {
	readonly httpRequest: BaseHttpRequest;
	constructor(httpRequest: BaseHttpRequest);
	private getTokenCancelable;
	private getTenantConfigurationCancelable;
	private getTenantInfoCancelable;
	private getTenantTagsCancelable;
	private getTenantConnectorsCancelable;
	private getTenantConnectionsCancelable;
	private getTenantConnectionSchemaCancelable;
	private getDatasourceTokenCancelable;
	private getTenantDatasourcesCancelable;
	private getDatasourceCancelable;
	private createDatasourceCancelable;
	private getTenantContractsCancelable;
	private getTenantContractSchemaCancelable;
	private createConnectionCancelable;
	private getWorkflowDesignsCancelable;
	private exportWorkflowCancelable;
	private importWorkflowCancelable;
	private getWorkflowCancelable;
	private deleteDraftWorkflowCancelable;
	private saveWorkflowCancelable;
	private publishWorkflowCancelable;
	private deletePublishedWorkflowCancelable;
	private scheduleWorkflowCancelable;
	private getWorkflowEndpointsCancelable;
	private getTenantUsersCancelable;
	private getWorkflowOwnersCancelable;
	private updateWorkflowOwnersCancelable;
	private getWorkflowBusinessOwnersCancelable;
	private updateWorkflowBusinessOwnersCancelable;
	private getConnectionPermissionsCancelable;
	private updateConnectionPermissionsCancelable;
	private getDatasourcePermissionsCancelable;
	private updateDatasourcePermissionsCancelable;
	getToken(options: getTokenOptions): Promise<tokenResponse>;
	getTenantConfiguration(): Promise<tenantConfiguration>;
	getTenantInfo(tenantId: string): Promise<tenantInfo>;
	getTenantTags(): Promise<tagResponse>;
	getTenantConnectors(): Promise<getTenantConnectorsResponseType>;
	getTenantConnections(): Promise<getTenantConnectionsResponseType>;
	getTenantConnectionSchema(connectionId: string): Promise<connectionSchema>;
	getDatasourceToken(): Promise<getDatasourceTokenResponseType>;
	getTenantDatasources(): Promise<getTenantDatasourcesResponseType>;
	getDatasource(datasourceId: string): Promise<datasource>;
	createDatasource(payload: createDatasourcePayload): Promise<string>;
	getTenantContracts(includePublic?: boolean): Promise<Array<contract>>;
	getTenantContractSchema(contractId: string): Promise<any>;
	createConnection(appId: string, properties: createConnectionProperties): Promise<string>;
	getWorkflowDesigns(limit?: number): Promise<getWorkflowDesignsResponseType>;
	exportWorkflow(workflowId: string, options: exportWorkflowOptions): Promise<exportWorkflowResponse>;
	importWorkflow(options: importWorkflowOptions): Promise<importWorkflowResponse>;
	getWorkflow(workflowId: string): Promise<workflow>;
	deleteDraftWorkflow(workflowId: string): Promise<any>;
	saveWorkflow(workflowId: string, payload: saveWorkflowPayload): Promise<saveWorkflowResponse>;
	publishWorkflow(workflowId: string, payload: publishWorkflowPayload): Promise<workflow>;
	deletePublishedWorkflow(workflowId: string): Promise<any>;
	scheduleWorkflow(workflowId: string, payload: scheduleWorkflowPayload): Promise<workflow>;
	getWorkflowEndpoints(workflowId: string): Promise<workflowEndpoints>;
	getTenantUsers(): Promise<getTenantUsersResponseType>;
	getWorkflowOwners(workflowId: string): Promise<getWorkflowOwnersResponseType>;
	updateWorkflowOwners(workflowId: string, permissions: updateWorkflowOwnersPermissions): Promise<any>;
	getWorkflowBusinessOwners(workflowId: string): Promise<getWorkflowBusinessOwnersResponseType>;
	updateWorkflowBusinessOwners(workflowId: string, businessOwners: updateWorkflowBusinessOwnersBusinessOwners): Promise<any>;
	getConnectionPermissions(connectionId: string): Promise<getConnectionPermissionsResponseType>;
	updateConnectionPermissions(connectionId: string, permissions: updateConnectionPermissionsPermissions): Promise<any>;
	getDatasourcePermissions(datasourceId: string): Promise<getDatasourcePermissionsResponseType>;
	updateDatasourcePermissions(datasourceId: string, permissions: updateDatasourcePermissionsPermissions): Promise<any>;
}
export declare type HttpRequestConstructor = new (config: OpenAPIConfig) => BaseHttpRequest;
export declare class Nwc {
	readonly default: DefaultService;
	readonly request: BaseHttpRequest;
	constructor(config?: Partial<OpenAPIConfig>, HttpRequest?: HttpRequestConstructor);
}
export declare type ApiResult = {
	readonly url: string;
	readonly ok: boolean;
	readonly status: number;
	readonly statusText: string;
	readonly body: any;
};
export declare class ApiError extends Error {
	readonly url: string;
	readonly status: number;
	readonly statusText: string;
	readonly body: any;
	readonly request: ApiRequestOptions;
	constructor(request: ApiRequestOptions, response: ApiResult, message: string);
}
export declare type dataType = {
	name: string;
	version: number;
	subType?: string;
	schema?: {
		title: string;
		type: string;
		properties: any;
	};
};
export declare type actionConstraint = {
	constraintType: dataType;
	data: {
		field: string;
		filterType?: Array<string>;
		choices?: Array<any>;
	};
};
export declare type valueData = {
	name: string;
	value: any;
	valuePath?: string;
};
export declare type formatValue = {
	variable: {
		valueType: {
			data: valueData;
		};
	};
};
export declare type valueType = {
	type: dataType;
	data: {
		value: any;
	};
	validators: Array<any>;
};
export declare type parameter = {
	name: string;
	label: string;
	description: string;
	required: boolean;
	dataType: dataType;
	constraints: Array<actionConstraint>;
	direction: string;
	properties: any;
	value: {
		primitiveValue: {
			valueType: valueType;
			formatValues: Array<formatValue>;
		};
		variable: {
			valueType: any;
		};
	};
	placeholder: string;
	valueType?: any;
	hidden?: boolean;
	originalRequired?: boolean;
	helpText?: string;
	designerType?: string;
	dependentOn?: string;
	defaultValue?: any;
	renderData?: any;
};
export declare type property = {
	id: string;
	displayName: string;
	parameters: Array<parameter>;
};
export declare type actionConfiguration = {
	id: string;
	name: string;
	originalName: string;
	subHeader?: string;
	image: {
		svgIcon?: string;
		svgLight?: boolean;
		toolboxSrc: string;
		canvasSrc: string;
		configPanelSrc: string;
	};
	serverInfo: {
		className: string;
	};
	properties: Array<property>;
	stateConfiguration?: any;
	isDisabled: boolean;
	operationId?: string;
	xtensionId?: string;
	xtension?: {
		operationId: string;
		id: string;
		isAsyncAction: boolean;
		engineVersion: number;
	};
	actionConstraint?: actionConstraint;
	constraints: Array<actionConstraint>;
	isHidden?: boolean;
	isHiddenInToolbox?: boolean;
	isPublishable?: boolean;
	isCollapsed?: boolean;
};
export declare type action = {
	id: string;
	configuration: actionConfiguration;
	className: string;
	renderOptions: {
		type: string;
		branchMenuCommands: any;
	};
	requiredZone: any;
	invalidZone: any;
	requiredZoneErrorMessage: any;
	definesZone: any;
	_metaData?: Array<string>;
	children: Array<action>;
	next: action;
	previous: string;
	parent: string;
};
export declare type businessOwner = {
	type?: string;
	id?: string;
	name?: string;
};
export declare type connectionSchemaProperty = {
	title: string;
	"x-ntx-initial"?: string;
	"x-ntx-emit-undefined"?: string;
	type: string;
	default: string;
	format?: string;
	description?: string;
};
export declare type dataSourceVariableMethod = {
	literal?: string;
	schema?: any;
	data?: any;
	value?: any;
};
export declare type dataSourceVariable = {
	dataSourceId: string;
	config: {
		schema: {
			type: string;
			"x-ntx-variables": boolean;
			required: Array<string>;
		};
		value: Record<string, dataSourceVariableMethod>;
	};
};
export declare type formVariable = {
	id: string;
	connectedVariableId: string;
	displayName: string;
	dataType: {
		type: string;
		format: string;
	};
	formula?: {
		raw: string;
		compiled: string;
		usedVariableIds: string;
	};
	formModes?: Array<number>;
	formScopes?: Array<any>;
	config?: dataSourceVariable;
};
export declare type formDefinition = {
	id?: string;
	name?: string;
	ruleGroups: Array<any>;
	theme: any;
	pageSettings: any;
	version: number;
	formType: string;
	contract: any;
	variableContext: {
		variables: Array<formVariable>;
	};
	settings: any;
	rows: Array<any>;
	dataSourceContext: Record<string, {
		id: string;
	}>;
	submissionConfig: any;
};
export declare type settings = {
	id: string;
	title: string;
	description: string;
	type: string;
	author: user;
	_metaData: Array<string>;
	datasources: Record<string, {
		sources: Array<{
			id: string;
		}>;
		type: string;
	}>;
	overwriteExistingWorkflow: boolean;
	isPublishing: boolean;
	isActive: boolean;
	workflowMetaData?: {
		lastModified?: string;
		lastPublished?: string;
		isMigrated?: boolean;
		isDeactivatedInO365?: boolean;
		workflowName?: string;
		workflowDesignVersion?: string;
		tags?: Array<string>;
	};
};
export declare type startData = Array<{
	name: string;
	variable?: string;
	type: string;
	label?: string;
}>;
export declare type variable = {
	source: string;
	name: string;
	displayName: string;
	dataType: dataType;
	schema?: any;
	properties?: Array<{
		dataType: dataType;
		name: string;
		rawName: string;
		displayName: string;
	}>;
	scopeId?: string;
	outputId?: string;
	usedInActions: Array<string>;
	isInUse: boolean;
	isUsedInActions: boolean;
	configuration?: {
		description?: string;
		defaultValue: string;
	};
	output?: boolean;
	initiate?: boolean;
	isHidden?: boolean;
	"x-ntx-flagged": boolean;
};
export declare type workflowDatasources = Record<string, {
	sources: Array<{
		id: string;
	}>;
	type: string;
}>;
export declare type xtensionUsage = {
	xtension: any;
	usedByActionIds: Array<string>;
	usedByEventIds: Array<string>;
};
export declare type workflowDefinition = {
	state: {
		modified: boolean;
	};
	settings: settings;
	variables: Array<variable>;
	inUseXtensions: Record<string, xtensionUsage>;
	forms: any;
	formVersions: any;
	actions: action;
};
export declare type xtensionInfo = {
	title?: string;
	description?: string;
	version?: string;
};
export declare type xtension = {
	swagger: string;
	info: xtensionInfo;
	host: string;
	basePath: string;
	schemes: Array<string>;
	produces: Array<string>;
	paths: any;
	definitions: any;
	parameters: any;
	responses: any;
	securityDefinitions: any;
	security: Array<any>;
	"x-ntx-render-version"?: number;
	"x-ntx-host"?: string;
	"x-ntx-contract-id"?: string;
	"x-ntx-xtension-id"?: string;
	"x-ntx-xtension-app-id"?: string;
};
export interface ClientCredentials {
	clientId: string;
	clientSecret: string;
	isTestTenant?: boolean;
}
export interface Tenant {
	id: string;
	name: string;
	apiManagerUrl: string;
	host: string;
	serviceRegion: string;
	url: string;
}
export interface ActionConfigurationEntryValue {
	key: string;
	name: string;
	value: string | ActionConfigurationEntryValue[] | undefined;
	type: "value" | "variable" | "unsupported" | "dictionary";
}
export interface ActionConfigurationEntry extends ActionConfigurationEntryValue {
	path: string;
}
export interface ActionConfiguration {
	actionId: string;
	data: any;
	configuration: ActionConfigurationEntry[];
}
export interface DatasourceDependency {
	datasourceId: string;
	formIds: string[];
	name?: string;
	contractId: string;
	connectionId: string;
}
export interface ConnectionDependency {
	connectionId: string;
	connectionName: string;
	contractId: string;
	needsResolution: boolean;
	actions: {
		[actionId: string]: ActionConfiguration;
	};
	datasources: {
		[datasourceId: string]: DatasourceDependency;
	};
}
export interface ContractDependency {
	contractId: string;
	contractName: string;
	needsResolution: boolean;
	connections: {
		[key: string]: ConnectionDependency;
	};
}
export interface WorkflowDependency {
	workflowId: string;
	actionIds: string[];
}
export interface WorkflowDependencies {
	contracts: {
		[key: string]: ContractDependency;
	};
	workflows: {
		[key: string]: WorkflowDependency;
	};
}
export interface FormControlDatasourceConfig {
	config: {
		schema: any;
		value: {
			[key: string]: any;
		};
	};
	dataSourceId: string;
	dataSourceLabel: string;
	outputSchema: any;
	usedVariables: {
		[key: string]: any;
	};
}
export interface FormControlProperies {
	rows?: FormRow[];
	dataSourceConfiguration?: FormControlDatasourceConfig;
	items?: any;
}
export interface FormControl {
	id: string;
	properties: FormControlProperies;
	sourceVariable: {
		autoGenerateName: boolean;
		displayName: string;
		id: string;
	};
}
export interface FormRow {
	controls: FormControl[];
}
export interface FormVariable {
	id: string;
	config: FormControlDatasourceConfig;
}
export interface Form {
	id: string;
	name: string;
	ruleGroups: any[];
	theme: any;
	pageSettings: any;
	version: number;
	formType: string;
	contract: {
		version: number;
		variablePrefix: string;
	};
	variableContext: {
		variables: FormVariable[];
		version: number;
	};
	rows: FormRow[];
	settings: any;
	submissionConfig?: any;
	dataSourceContext?: {
		[key: string]: {
			id: string;
		};
	};
}
export interface WorkflowForms {
	taskForms?: {
		[key: string]: Form;
	};
	startForm?: Form;
}
export interface Tag {
	name: string;
	colorIndex: number;
	count: number;
}
export interface User {
	id: string;
	roles?: Array<string>;
	firstName?: string;
	lastName?: string;
	email?: string;
	name?: string;
}
export interface WorkflowInfo {
	isActive: boolean;
	eventType?: string;
	isPublished: boolean;
	publishedId?: string;
	status?: string;
	version?: number;
	description?: string;
	comments?: string;
	type?: string;
	designVersion?: string;
	engine: string;
	tags: Tag[];
	author: User;
}
export interface Permission {
	id: string;
	name: string;
	email?: string;
	type: string;
	isOwner: boolean;
	isUser: boolean;
}
export interface Workflow {
	id: string;
	name: string;
	info: WorkflowInfo;
	forms: WorkflowForms;
	definition: workflowDefinition;
	dependencies: WorkflowDependencies;
	permissions: Permission[];
	startEvents?: workflowStartEvent[];
	startFormUrl?: string;
}
export interface Contract {
	id: string;
	name: string;
	description?: string;
	appId: string;
	icon: string;
	actions: {
		type: string;
		name: string;
	}[];
	events: {
		type: string;
		name: string;
	}[];
}
export interface WorkflowDesign {
	id: string;
	name: string;
	engine?: string;
	tags: Tag[];
	formUrl?: string;
	businessOwners: Permission[];
}
export interface Connection {
	id: string;
	name: string;
	isValid: boolean;
	contractId: string;
	nwcObject: connection;
}
export interface Datasource {
	id: string;
	name: string;
	contractId: string;
	connectionId: string;
	operationId: string;
	isValid: boolean;
	definition: string;
	description: string;
	nwcObject: datasource;
}
export interface ConnectionProperty {
	title: string;
	value?: string;
	type: string;
	format?: string;
	decription?: string;
}
export interface ConnectionSchema {
	title: string;
	description?: string;
	type: string;
	properties: {
		[key: string]: ConnectionProperty;
	};
	required: string[];
}
export interface WorkflowsQueryOptions {
	tag?: string;
	namePattern?: string;
}
export declare const invalidId = "undefined";
export declare class Sdk {
	private _tenant;
	private _nwc;
	private _token;
	private _datasourceToken;
	private _user;
	get nwc(): Nwc;
	get tenant(): Tenant;
	get user(): User;
	private constructor();
	private _defaultPermisssions;
	clearCache(): void;
	static connectWithClientCredentials(credentials: ClientCredentials): Promise<Sdk>;
	static connectWithToken(token: string, isTestTenant?: boolean): Promise<Sdk>;
	getTags(): Promise<Tag[]>;
	getWorkflowDesigns(options?: WorkflowsQueryOptions): Promise<WorkflowDesign[]>;
	getWorkflowDesign: (workflowId: string) => Promise<WorkflowDesign | undefined>;
	getWorkflowDesignByName: (workflowName: string) => Promise<WorkflowDesign | undefined>;
	private resolveDependencies;
	getWorkflow(workflowId: string): Promise<Workflow>;
	tryGetWorkflow: (workflowId: string) => Promise<Workflow | undefined>;
	checkIfWorkflowExists: (workflowName: string) => Promise<boolean>;
	getWorkflowByName(workflowName: string): Promise<Workflow | undefined>;
	getWorkflowPermissions(workflowId: string): Promise<Permission[]>;
	updateWorkflowPermissions(workflowId: string, permissions: Permission[]): Promise<void>;
	getUsers(): Promise<User[]>;
	deleteWorkflow(workflowId: string): Promise<void>;
	getConnections(): Promise<Connection[]>;
	getConnection(connectionId: string): Promise<Connection | undefined>;
	getConnectionByName: (name: string) => Promise<Connection | undefined>;
	getConnectionSchema(connectionId: string): Promise<ConnectionSchema>;
	getContracts(): Promise<Contract[]>;
	getContract(id: string): Promise<Contract | undefined>;
	getContractByName(name: string): Promise<Contract | undefined>;
	getContractSchema(contractId: string): Promise<OpenAPIV2.Document>;
	getContractConnectionProperties(contractId: string): Promise<{
		[key: string]: ConnectionProperty;
	}>;
	getDatasources(): Promise<Datasource[]>;
	getDatasource(id: string): Promise<Datasource>;
	tryGetDatasource: (id: string) => Promise<Datasource | undefined>;
	getDatasourceByName: (name: string) => Promise<Datasource | undefined>;
	createDatasource(payload: datasourcePayload, permissions?: Permission[]): Promise<Datasource | undefined>;
	exportWorkflow: (id: string, withNonExpiringKey?: boolean) => Promise<string>;
	importWorkflow(name: string, key: string, overwriteExisting?: boolean): Promise<Workflow>;
	createConnection(contract: Contract, properties: Record<string, string>, permissions?: Permission[]): Promise<Connection | undefined>;
	publishWorkflow(workflow: Workflow): Promise<Workflow>;
	saveWorkflow(workflow: Workflow): Promise<Workflow>;
	private ensureCorrectAuthorInDefinition;
}
export declare class DatasourceHelper {
	static ensureConnectionInDefinition: (definition: string, newConnectionId: string) => string;
	static parseDefinition: (definition: string) => any;
	static stringifyDefinition: (definition: any) => string;
	static processDefinition: (definition: string) => {
		generilisedDefinition: any;
		contractId: string;
		connectionId: string;
	};
}
export declare class WorkflowHelper {
	static parseDefinition: (definition: string) => workflowDefinition;
	static stringifyDefinition: (definition: workflowDefinition) => string;
	static ensureWorkflowId: (definition: workflowDefinition, workflowId: string) => void;
	static resolveActionConfigurationEntryValue: (entry: {
		parameter: OpenAPIV2.Parameter | string;
		value: any;
	}) => ActionConfigurationEntryValue;
	static actionsArray: (definition: workflowDefinition) => action[];
	static actionsDictionary: (definition: workflowDefinition) => {
		[key: string]: action;
	};
	static dependencies: (definition: workflowDefinition, forms: WorkflowForms) => WorkflowDependencies;
	static allContractDependencies: (dependencies: WorkflowDependencies) => ContractDependency[];
	static allWorkflowDependencies: (dependencies: WorkflowDependencies) => WorkflowDependency[];
	static allConnectionDependencies: (dependencies: WorkflowDependencies) => ConnectionDependency[];
	static allDatasourceDependencies: (dependencies: WorkflowDependencies) => DatasourceDependency[];
	private static _addToDatasource;
	private static ensureDatasources;
	private static workflowDependencies;
	private static resolveConnectionDependencies;
	private static resolveDatasourceDependencies;
	static forms: (definition: workflowDefinition, startEvents?: workflowStartEvent[]) => WorkflowForms;
	static swapConnection: (workflow: Workflow, connectionId: string, newConnection: Connection, connectionName: string, newContract: Contract, newContractSchema: OpenAPIV2.Document) => void;
	static swapDatasource: (workflow: Workflow, datasourceId: string, newDatasource: Datasource, newConnection: Connection) => void;
	static swapWorkflowDependency: (workflow: Workflow, existingWorkflowId: string, newWorkflowId: string) => void;
	static findConnectionDependency: (workflow: Workflow, connectionId: string) => ConnectionDependency | undefined;
}
export declare const isError: (value: (any | ApiError)) => value is ApiError;
export declare const isNotError: <T>(value: ApiError | T) => value is T;
export declare const unWrapResponse: <T>(value: ApiError | T) => T | undefined;
export declare const unWrapError: (value: (any | ApiError)) => ApiError | undefined;
export declare const unWrapResponseOrThrow: <T>(value: ApiError | T) => T;
export declare const unWrapErrorOrThrow: (value: (any | ApiError)) => ApiError;
export declare const isFormControl: (value: (any | FormControl)) => value is FormControl;
export declare const isForm: (value: (any | Form)) => value is Form;
export declare const arrayToDictionary: <T>(array: T[], keyProperty: string) => {
	[key: string]: T;
};
export declare const flattenTree: <Type>(node: Type, childPropertyName: string, childNodeArrayPropertyName?: string) => Type[];
export declare const findOperation: (paths: OpenAPIV2.PathsObject, operationId: string) => OpenAPIV2.OperationObject | undefined;
export declare namespace Specifications {
	const swagger: () => OpenAPIV2.Document;
	const postman: () => Collection;
}

export {};
